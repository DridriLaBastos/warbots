;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; le code de l'equipe rouge basique
;; préfixe : red-team
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to dridriTeamForwardMove
  let i 0
  while [ free-ahead? speed != nobody and i < 6]
  [
    rt 60
    set i i + 1
  ]
  
  if free-ahead? speed = nobody [ forward-move speed ]
end

to-report dridriTeamMoveToTarget [ d ]
  ifelse (mem5 != 0) and (distance mem5 > d)
  [
    set heading towards mem5
    dridriTeamForwardMove
    report false
  ]
  [
    ;print self
    ;type "   " type mem5 type " --> "
    set mem5 0
    ;print mem5
    report true
  ]
end

to-report dridriTeamGetBreedCost [ b ]
  if b = Harvesters [ report harvester-cost ]
  if b = Explorers  [ report explorer-cost ]
  if b = RocketLaunchers [ report rocket-launcher-cost ]
end

to dridriTeamRandomMove
  set heading heading - 20 + random 40
  dridriTeamForwardMove
end

;;;;;;;;;;;;;;;;;;;;;;
;; --- EXPLORER --- ;;
;;;;;;;;;;;;;;;;;;;;;;

to dridriTeamExplorerSearchEnemyBases
  dridriTeamRandomMove
  let enemyBase one-of perceive-base ennemy
  
  if enemyBase != nobody
  [
    set mem0 (mem0 + 1)
    set mem1 enemyBase
    set mem5 min-one-of my-bases [ distance myself ]
  ]
end

;On récupère une base qui n'a pas de coodonnées pour les bases énemies
to dridriTeamExplorerRevealEnemyBase
  ; Une fois que l'on est arrivé à distance de communication d'une base, on vérifie qu'elle ne contient pas déjà la position
  ; de la base que l'on contient et on lui donne cette info
  ; dans tous les cas on se dirige vers la base suivante pour lui passer la position de la base que l'on a trouvé
  let b mem5
  if dridriTeamMoveToTarget detection-range
  [
    let enemyBases [mem10] of b
    
    ifelse enemyBases = 0
    [ set enemyBases (list mem1) ]
    [ if (length enemyBases = 1) and (item 0 enemyBases != mem1) [ set enemyBases lput mem1 enemyBases ] ]
    
    ask b [ set mem10 enemyBases ]
    set mem5 one-of my-bases with [ self != b ]
    set mem3 (mem3 + 1)
    if mem3 = 2
    [
      set mem0 0
      set mem3 0
    ]
  ]
end

to goRedExplorer
  if mem0 = 0 [ dridriTeamExplorerSearchEnemyBases ]
  if mem0 = 1 [ dridriTeamExplorerRevealEnemyBase ]
end

;;;;;;;;;;;;;;;;;;;;;
;; --- SOLDIER --- ;;
;;;;;;;;;;;;;;;;;;;;;

to dridriTeamSoldierGoToMeetPoint
  let meetPoint mem5
  if dridriTeamMoveToTarget 1
  [
    set mem0 (mem0 + 1)
    set mem5 meetPoint
  ]
end

to dridriTeamSoldierSwitchToAttack [ baseTarget ]
  set mem0 2
  set mem5 baseTarget
end

to dridriTeamSoldierWaitForAttack
  if distance mem5 > 2 [ set heading towards mem5 ]
  dridriTeamRandomMove
  
  let soldierAround perceive-specific-robots color RocketLaunchers
  if count soldierAround >= 6
  [
    let r random 2
    let baseTargets 0
    
    if mem1 != 0 [ set baseTargets (list mem1) ]
    if mem2 != 0 [ set baseTargets lput baseTargets mem2 ]
    
    let baseTarget item (random length baseTargets) baseTargets
    
    dridriTeamSoldierSwitchToAttack baseTarget
    ask soldierAround with [ mem0 != 2 ]
    [ dridriTeamSoldierSwitchToAttack baseTarget ]
  ]
end

to dridriSoldierAttack
  let t mem5
  if dridriTeamMoveToTarget 0
  [
    set mem5 t
    ifelse nb-missiles > 0
    [ launch-rocket towardsxy [xcor] of mem5 [ycor] of mem5 ]
    [
      ifelse nb-fafs > 0
      [ launch-faf mem5 ]
      [
        set mem5 min-one-of my-bases [ distance myself ]
        set mem0 (mem0 + 1)
      ]
    ]
  ]
end

to dridriTeamSoldierReturnBase
  if dridriTeamMoveToTarget (.95 * [ detection-range ] of mem5)
  [
    ;On se suicide pour le moment mais il faudra demander à se revigorer
    set energy 0
  ]
end

to goRedRocketLauncher
  if mem0 = 0 [ dridriTeamSoldierGoToMeetPoint ]
  if mem0 = 1 [ dridriTeamSoldierWaitForAttack ]
  if mem0 = 2
  [
    if [energy] of mem5 < 0
    [
      ifelse mem5 = mem1
      [ set mem5 mem2 ]
      [ set mem5 mem1 ]
    ]
    dridriSoldierAttack
  ]
  if mem0 = 3 [ dridriTeamSoldierReturnBase ]
end

;;;;;;;;;;;;;;;;;;;;;;;
;; --- HARVESTER --- ;;
;;;;;;;;;;;;;;;;;;;;;;;
to dridriTeamHarvesterRevealFoodPosition
  ;On dit aux autre harvesters qui cherchent de la nourriture où se trouve la source que l'on a trouvée
  if mem1 != nobody
  [
    let callerMem1 mem1
    ask (perceive-specific-robots color Harvesters) with [ mem4 = 500 ]
    [
        if distance callerMem1 > 2
        [ if mem1 = nobody [ set mem1 callerMem1 ] ]
      ]
  ]
end

to dridriTeamHarvesterSearchFood
  ;Ramassage de la nouriture
  let f min-one-of perceive-food [ distance myself ]

  while [(f != nobody) and (distance f <= 2)] [
    take-food f
    set f min-one-of perceive-food [ distance myself ]
    set mem1 nobody
  ]
  
  ;Avancer vers le reste de la nouriture, vers un spot de nouriture, ou au hasard
  ifelse f != nobody
  [
    set heading towards f
    dridriTeamForwardMove
  ]
  [
    ifelse mem1 = nobody
    [ dridriTeamRandomMove ]
    [ set mem5 mem1 if dridriTeamMoveToTarget 2 [ set mem1 nobody ] ]
  ]
  
  ;Quand on atteind le seuil, on rentre à la base
  if carrying-food? >= mem4
  [
    ;On sauvegarde où on a trouvé de la nourriture pour pouvoir continuer à donner cette information à d'autre harvester dans le chemin vers la base
    set mem0 (mem0 + 1)
    set mem1 patch-here
    set mem5 mem3
  ]
  
  ;Si on cherche de la nourriture autour de la base, on ne dépasse pas son rayon
  if mem4 >= 2000
  [
    if distance mem3 >= missile-range
    [ set heading towards mem3 ]
  ]
end

to dridriTeamHarvesterComeToBase
  if dridriTeamMoveToTarget (missile-range * .95)
  [ set mem0 (mem0 + 1) ]
end

to dridriTeamHarvesterPlantSeeds
  ;Si l'on veut planter des graines, la base nous attribut un patch dans mem5 donc nous allons vers celui-ci
  if dridriTeamMoveToTarget 0 []
  
  ;Une fois qu'on a atteind le patch, on plante une graine et on se remet en attente d'un patch
  if patch-here = mem5
  [
    plant-seeds color max-seeds
    ;ask mem5 [ set pcolor black ]
    set mem5 0
    set mem2 mem2 + 1
  ]
  
  ;Une fois que l'on a planté toutes les graînes que l'on doit planter, on va nourrir la base
  if (mem2 >= 10) or (carrying-food? < max-seeds * seed-cost)
  [
    set mem0 (mem0 + 1)
    set mem2 0
    set mem5 mem3
  ]
end

to dridriTeamHarvesterFeedBase
  if dridriTeamMoveToTarget 2
  [
    give-food mem3 carrying-food?
    set mem0 0
    ifelse mem4 = 500
    [
      set mem1 nobody
      set mem4 2000
    ]
    [ set mem4 min (list 6000 (mem4 + 1000)) ]
  ]
end

;Se déplace aléatoirement. Quand ils trouvent de la nourriture en donne 80% à la base et plante ce qui reste
to goRedHarvester
  let harvesterAround (perceive-specific-robots color Harvesters) with [ mem1 != nobody ] 
  if count harvesterAround > 3
  [ set mem1 nobody ]
  dridriTeamHarvesterRevealFoodPosition
  if mem0 = 0 [ dridriTeamHarvesterSearchFood ]
  if mem0 = 1 [ dridriTeamHarvesterComeToBase ]
  if mem0 = 2 [ dridriTeamHarvesterPlantSeeds ]
  if mem0 = 3 [ dridriTeamHarvesterFeedBase ]
end

;;;;;;;;;;;;;;;;;;
;; --- BASE --- ;;
;;;;;;;;;;;;;;;;;;

to dridriTeamBaseAssignPatchesToHarvestingHarvesters
  let harvestingHarvesters (perceive-specific-robots color Harvesters) with [ (mem0 = 2) ]
  let demandingHarvesters harvestingHarvesters with [ mem5 = 0 ]
  
  let possiblePatches (mem9 with-min [ count Seeds-here ]) with-min [ count harvestingHarvesters with [ mem5 = myself ] ]

  let attributedPatches sort (min-n-of count harvestingHarvesters possiblePatches [ distance myself ]);création d'une liste à partir d'un agent set
  
  let i 0
  ask demandingHarvesters
  [
    let attributedPatch item i attributedPatches
    ;ask attributedPatch [ set pcolor green ]
    set mem5 attributedPatch
    set i i + 1
  ]
end

to dridriTeamBaseUpdateAvailableEnergy
  let dEnergy energy - mem11
  set mem8 max (list 0 (mem8 + 0.70 * dEnergy))
end

to dridriTeamBaseRequests [ n b ]
  ifelse b = Harvesters
  [ set mem0 max (list 0 (mem0 + n)) ]
  [
    ifelse b = Explorers
    [ set mem1 max (list 0 (mem1 + n)) ]
    [
      if b = RocketLaunchers
      [ set mem2 max (list 0 (mem2 + n)) ]
    ]
  ]
  ;C'est quand même étrange que cette vession avec les if à la ligne ne fonctionne pas
  ;if b = Harvesters [ set mem0 max (list 0 (mem0 + n)) ]
  ;if b = Explorers [ set mem1 max (list 0 (mem1 + n)) ]
  ;if b = RocketLaunchers [ set mem2 max (list 0 (mem2 + n)) ]
  ;print (list mem0 mem1 mem2)
end

;Si le nombre d'harvesters est plus petit qu'une certaines valeur, recréer des harvesters
to dridriTeamBaseConditionalyRequestHarvester
  let harvesterThreshold 5
  let harvesterNumber count perceive-specific-robots color Harvesters
  ifelse harvesterNumber < harvesterThreshold
  [ dridriTeamBaseRequests 1 Harvesters ] 
  [ if mem0 > 0 [ dridriTeamBaseRequests -1 Harvesters ]]
end

;Si on a perdu de l'énergie  alors on enlèvera des soldats de la file d'attente
to dridriTeamBaseConditionalyRequestSoldier
  if mem10 != 0
  [
      let soldierQuantity mem8 / dridriTeamGetBreedCost RocketLaunchers
      let newSoldierAmount floor soldierQuantity
      
      if newSoldierAmount > 0
      [
        dridriTeamBaseRequests newSoldierAmount RocketLaunchers
        set mem8 (mem8 - newSoldierAmount * dridriTeamGetBreedCost RocketLaunchers)
      ]
  ]
end

to dridriTeamBaseConditionalyRequestExplorer
  if ((mem10 = 0) or (length mem10 != 2)) and (ticks mod 400 = 0)
  [ dridriTeamBaseRequests 1 Explorers ]
end

to dridriTeamBaseConditionalyRequestBots
  ;dridriTeamBaseConditionalyRequestHarvester
  dridriTeamBaseConditionalyRequestSoldier
  dridriTeamBaseConditionalyRequestExplorer
end

to dridriTeamBaseCreate [ b ]
  if (b = Harvesters) and (mem0 > 0)
  [
    new-Harvester self
    set mem0 (mem0 - 1)
  ]

  if (b = Explorers) and (mem1 > 0)
  [
    new-Explorer self
    set mem1 (mem1 - 1)
  ]
  
  if (b = RocketLaunchers) and (mem2 > 0)
  [
    new-RocketLauncher self
    set mem2 (mem2 - 1)
  ]
end

to dridriTeamBaseCreateBots
  if create-ok? [ dridriTeamBaseCreate Harvesters ]
  if create-ok? [ dridriTeamBaseCreate Explorers ]
  if create-ok? [ dridriTeamBaseCreate RocketLaunchers ]
end

to dridriTeamBaseLaunchFAF [ t ]
  if nb-fafs = 0 [ new-faf 1 ]
  launch-faf t
end

to dridriTeamBaseConditionnalyLaunchFAF
  ;Détection de tous les lanceurs de missiles ennemis à proximité
  let ennemySoldierAround perceive-specific-robots ennemy RocketLaunchers
  ;let ennemySoldierAround perceive-robots ennemy
  let ennemyList sort-on [ distance myself ] ennemySoldierAround
  
  let i 0
  while [ i < length ennemyList ]
  [
    let possibleTarget item i ennemyList
    set heading towards possibleTarget
    
    ;On récupère le nombre de harvesters dans un cône entre la base et une cible possible
    let harvestersInWay (Harvesters with [ color = [color] of myself ]) in-cone (distance possibleTarget) 30
    
    if count harvestersInWay <= 3
    [
      dridriTeamBaseLaunchFAF possibleTarget
      set i length ennemyList
    ]
    set i (i + 1)
  ]
end

to goRedBase
  ;On fait cette mise en mémoire ici car dans init base les murs ne sont pas encore placés et certains harvesters ne vont jamais réussir à atteindre
  ; le patch s'il y a un mur dessus
  if ticks = 0 [ set mem9 (patches in-radius detection-range) with [ (count Bases-here = 0) and (count Walls-here = 0)] ]
  ;Ce n'est pas la peine de lancer ce code toutes les ticks
  dridriTeamBaseAssignPatchesToHarvestingHarvesters
  dridriTeamBaseUpdateAvailableEnergy
  dridriTeamBaseConditionalyRequestBots
  dridriTeamBaseCreateBots

  dridriTeamBaseConditionnalyLaunchFAF
  set mem11 energy
end

;; procedure pour initialiser les explorers rouges
to initRedExplorer
end

;; procedure pour initialiser les rocket-launchers rouges
to initRedRocketLauncher
  let creator my-bases with-min [ distance myself ]
  let ennemyBases 0
  
  ask creator [ set ennemyBases mem10 ]
  
  print ennemyBases
  print (item 0 ennemyBases)
  
  if ennemyBases != 0
  [
    set mem1 (item 0 ennemyBases)
    if length ennemyBases = 2 [ set mem2 (item 1 ennemyBases) ]
  ]
  
  let meetPointX (mean [ xcor ] of my-bases) + 10
  let meetPointY mean [ ycor ] of my-bases
  set mem5 (patch meetPointX meetPointY)
end

;; procedure pour initialiser les rocket-launchers rouges
to initRedHarvester
  set mem1 nobody
  set mem3 min-one-of my-bases [ distance myself ]
  set mem4 500
end

;; procedure pour initialiser les bases rougesinifinie
to initRedBase
  set mem11 energy
  set mem10 (list (base 6))
  ;dridriTeamBaseRequests 15 Harvesters
end

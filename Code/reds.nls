;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; le code de l'equipe rouge basique
;; préfixe : red-team
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
globals [ count_ ]

;fonction atan(x), netlogo ne fournit que atan(x,y)
to-report atan1 [ x ]
  report 1 - atan 1 x * 2 / 180
end

to dridriTeamForwardMove
  let i 0
  while [ free-ahead? speed != nobody and i < 3]
  [
    rt 120
    set i i + 1
  ]
  
  if free-ahead? speed = nobody [ forward-move speed ]
end

to-report dridriTeamMoveToTarget [ d ]
  ifelse distance mem5 > d
  [
    set heading towards mem5
    dridriTeamForwardMove
    report false
  ]
  [
    ;print self
    ;type "   " type mem5 type " --> "
    set mem5 0
    ;print mem5
    report true
  ]
end

to-report dridriTeamGetBreedCost [ b ]
  if b = Harvesters [ report harvester-cost ]
  if b = Explorers  [ report explorer-cost ]
  if b = RocketLaunchers [ report rocket-launcher-cost ]
end

to dridriTeamRandomMove
  let patchDir min-one-of neighbors in-cone 5 135 [ count Seeds-here ]
  set heading towards patchDir
  dridriTeamForwardMove
end

;;;;;;;;;;;;;;;;;;;;;;
;; --- EXPLORER --- ;;
;;;;;;;;;;;;;;;;;;;;;;

to dridriTeamExplorerSearchEnemyBases
  dridriTeamRandomMove
  let enemyBase one-of perceive-base ennemy
  
  if enemyBase != nobody
  [
    set mem0 1
    set mem1 enemyBase
    set mem5 min-one-of my-bases [ distance myself ]
  ]
end

;On récupère une base qui n'a pas de coodonnées pour les bases énemies
to dridriTeamExplorerRevealEnemyBase
  ; Une fois que l'on est arrivé à distance de communication d'une base, on vérifie qu'elle ne contient pas déjà la position
  ; de la base que l'on contient et on lui donne cette info
  ; dans tous les cas on se dirige vers la base suivante pour lui passer la position de la base que l'on a trouvé
  if dridriTeamMoveToTarget [detection-range] of mem5
  [
    let enemyBases [mem10] of mem5
    
    ifelse enemyBases = 0
    [ set enemyBases (list mem1) ]
    [ if (length enemyBases = 1) and (item 0 enemyBases != mem1) [ set enemyBases lput mem1 enemyBases ] ]
    
    ask mem5 [ set mem10 enemyBases ]
    set mem5 one-of my-bases with [ self != [mem5] of myself ]
    set mem3 (mem3 + 1)
    if mem3 = 2
    [
      set mem0 0
      set mem3 0
    ]
  ]
end

to goRedExplorer
  if mem0 = 0 [ dridriTeamExplorerSearchEnemyBases ]
  if mem0 = 1 [ dridriTeamExplorerRevealEnemyBase ]
end

;;;;;;;;;;;;;;;;;;;;;
;; --- SOLDIER --- ;;
;;;;;;;;;;;;;;;;;;;;;

to dridriTeamSoldierGoToMeetPoint
  if dridriTeamMoveToTarget 1
  [ set mem0 1 ]
end

to dridriTeamSoldierSwitchToAttack [ baseTarget ]
  set mem0 2
  set mem5 baseTarget
end

to dridriTeamSoldierWaitForAttack
  let soldierAround perceive-specific-robots color RocketLaunchers
  let headingPatch patch (mean [xcor] of soldierAround) (mean [ycor] of soldierAround)
  set heading towards headingPatch
  dridriteamForwardMove
  
  if count soldierAround >= 4
  [
    let baseTarget one-of (list mem1 mem2)
    
    dridriTeamSoldierSwitchToAttack baseTarget
    ask soldierAround with [ mem0 != 2 ]
    [ dridriTeamSoldierSwitchToAttack baseTarget ]
  ]
end

to dridriSoldierAttack
  if dridriTeamMoveToTarget 1
  [
    ifelse nb-missiles > 0
    [ launch-rocket towardsxy [xcor] of mem5 [ycor] of mem5 ]
    [
      ifelse nb-fafs > 0
      [ launch-faf mem5 ]
      [
        set mem5 min-one-of my-bases [ distance myself ]
        set mem0 3
      ]
    ]
  ]
end

to dridriTeamSoldierReturnBase
  if dridriTeamMoveToTarget (.95 * [ detection-range ] of mem5) []
end

to goRedRocketLauncher
  if mem0 = 0 [ dridriTeamSoldierGoToMeetPoint ]
  if mem0 = 1 [ dridriTeamSoldierWaitForAttack ]
  if mem0 = 2
  [
    if [energy] of mem5 < 0
    [
      ifelse mem5 = mem1
      [ set mem5 mem2 ]
      [ set mem5 mem1 ]
    ]
    dridriSoldierAttack
  ]
  if mem0 = 3 [ dridriTeamSoldierReturnBase ]
end

;;;;;;;;;;;;;;;;;;;;;;;
;; --- HARVESTER --- ;;
;;;;;;;;;;;;;;;;;;;;;;;

to dridriTeamHarvesterRevealFoodPosition
  ;On dit aux autre harvesters qui cherchent de la nourriture où se trouve la source que l'on a trouvée
  if mem1 != 0
  [
    ask perceive-specific-robots color Harvesters
    [
      ;Si le harvester cherche de la nourriture
      if mem0 = 0
      [
        ;Si la nouriture est dans le rayon de recherche : un harvester qui a trouvé de la nourriture plus loin que le rayon de la base ne donne
        ;pas la position de la nourriture à un harvester qui ne cherche qu'autour de la base
        if not(([mem4] of myself = 500) and (mem4 = 2000))
        [  set mem1 [mem1] of myself ]
      ]
    ]
  ]
end

to dridriTeamHarvesterSearchFood
  ;Ramassage de la nouriture
  let f min-one-of perceive-food [ distance myself ]
  let p 0

  while [(f != nobody) and (distance f <= 2)] [
    set p [patch-here] of f
    take-food f
    set f min-one-of perceive-food [ distance myself ]
    set mem1 0; Si on trouve de la nourriture ce n'est pas la peine de se rappeler où il y en avait
  ]
  
  ;Avancer vers le reste de la nouriture, vers un spot de nouriture, ou au hasard
  ifelse f != nobody
  [
    dridriTeamHarvesterRevealFoodPosition
    set heading towards f
    dridriTeamForwardMove
  ]
  [
    ifelse mem1 = 0
    [ dridriTeamRandomMove ]
    [ set mem5 mem1 if dridriTeamMoveToTarget (detection-range * .95) [] ]
  ]
  
  ;Quand on atteind le seuil, on rentre à la base
  if carrying-food? >= item 0 mem4
  [
    ;On sauvegarde où on a trouvé de la nourriture pour pouvoir continuer à donner cette information à d'autre harvester dans le chemin vers la base
    set mem0 (mem0 + 1)
    set mem1 ifelse-value p = nobody [0] [p]
    set mem5 mem3
  ]
  
  ;Si on cherche de la nourriture autour de la base, on ne dépasse pas son rayon
  if item 0 mem4 = 2000
  [
    if distance mem3 >= missile-range
    [ set heading towards mem3 ]
  ]
end

to dridriTeamHarvesterComeToBase
  if dridriTeamMoveToTarget missile-range
  [ set mem0 (mem0 + 1) ]
end

to dridriTeamHarvesterPlantSeeds
  ;Plantage des graines dans les patches qui en ont le moins
  if  (mem2 < 10)
  [ 
    ifelse mem5 = 0
    [
      set mem5 min-one-of neighbors with [ distance [mem3] of myself < missile-range ] [ count Seeds-here ]
      ;ask mem5 [ set pcolor green ]
    ]
    [
      if dridriTeamMoveToTarget 0 []
      
      if patch-here = mem5
      [
        plant-seeds color max-seeds
        ;ask mem5 [ set pcolor black ]
        set mem5 0
        set mem2 mem2 + 1
      ]
    ]
  ]
  
  ;Une fois que l'on a planté toutes les graînes que l'on doit planter, on va nourrir la base
  if mem2 >= 10
  [
    set mem0 (mem0 + 1)
    set mem2 0
    set mem5 mem3
  ]
end

to dridriTeamHarvesterFeedBase
  if dridriTeamMoveToTarget 2
  [
    ;print self
    ;type "   " type carrying-food? type " --> "
    give-food mem3 carrying-food?
    ;print carrying-food?
    set mem0 0
    set mem4 (list 2000 item 0 mem4)
  ]
end

;Se déplace aléatoirement. Quand ils trouvent de la nourriture en donne 80% à la base et plante ce qui reste
to goRedHarvester
  dridriTeamHarvesterRevealFoodPosition
  if mem0 = 0 [ dridriTeamHarvesterSearchFood ]
  if mem0 = 1 [ dridriTeamHarvesterComeToBase ]
  if mem0 = 2 [ dridriTeamHarvesterPlantSeeds ]
  if mem0 = 3 [ dridriTeamHarvesterFeedBase ]
  if (item 0 mem4) != (item 1 mem4) [ set mem1 0 ]
end

;;;;;;;;;;;;;;;;;;
;; --- BASE --- ;;
;;;;;;;;;;;;;;;;;;

to dridriTeamBaseUpdateAvailableEnergy
  let dEnergy energy - mem11
  set mem9 max (list 0 (mem9 + 0.80 * dEnergy))
end

to dridriTeamBaseRequests [ n b ]
  ;type self type " " type n type " " print b
  ;print (list mem0 mem1 mem2)
  ifelse b = Harvesters
  [ set mem0 max (list 0 (mem0 + n)) ]
  [
    ifelse b = Explorers
    [ set mem1 max (list 0 (mem1 + n)) ]
    [
      if b = RocketLaunchers
      [ set mem2 max (list 0 (mem2 + n)) ]
    ]
  ]
  ;C'est quand même étrange que cette vession avec les if à la ligne ne fonctionne pas
  ;if b = Harvesters [ set mem0 max (list 0 (mem0 + n)) ]
  ;if b = Explorers [ set mem1 max (list 0 (mem1 + n)) ]
  ;if b = RocketLaunchers [ set mem2 max (list 0 (mem2 + n)) ]
  ;print (list mem0 mem1 mem2)
end

;Si le nombre d'harvesters est plus petit qu'une certaines valeur, recréer des harvesters
to dridriTeamBaseConditionalyRequestHarvester
  let harvesterThreshold 5
  let harvesterNumber count perceive-specific-robots color Harvesters
  ifelse harvesterNumber < harvesterThreshold
  [ dridriTeamBaseRequests 1 Harvesters ] 
  [ if mem0 > 0 [ dridriTeamBaseRequests -1 Harvesters ]]
end

;Si on a perdu de l'énergie  alors on enlèvera des soldats de la file d'attente
to dridriTeamBaseConditionalyRequestSoldier
  if mem10 != 0
  [
      let soldierQuantity mem9 / dridriTeamGetBreedCost RocketLaunchers
      let newSoldierAmount floor soldierQuantity
      
      if newSoldierAmount > 0
      [
        dridriTeamBaseRequests newSoldierAmount RocketLaunchers
        set mem9 (mem9 - newSoldierAmount * dridriTeamGetBreedCost RocketLaunchers)
      ]
  ]
end

to dridriTeamBaseConditionalyRequestExplorer
  if ((mem10 = 0) or (length mem10 != 2)) and (ticks mod 400 = 0)
  [ dridriTeamBaseRequests 1 Explorers ]
end

to dridriTeamBaseConditionalyRequestBots
  ;dridriTeamBaseConditionalyRequestHarvester
  dridriTeamBaseConditionalyRequestSoldier
  dridriTeamBaseConditionalyRequestExplorer
end

to dridriTeamBaseCreate [ b ]
  if (b = Harvesters) and (mem0 > 0)
  [
    new-Harvester self
    set mem0 (mem0 - 1)
  ]

  if (b = Explorers) and (mem1 > 0)
  [
    new-Explorer self
    set mem1 (mem1 - 1)
  ]
  
  if (b = RocketLaunchers) and (mem2 > 0)
  [
    new-RocketLauncher self
    set mem2 (mem2 - 1)
  ]
end

to dridriTeamBaseCreateBots
  if create-ok? [ dridriTeamBaseCreate Harvesters ]
  if create-ok? [ dridriTeamBaseCreate Explorers ]
  if create-ok? [ dridriTeamBaseCreate RocketLaunchers ]
end

to dridriTeamBaseLaunchFAF
   let missileLaunchThreshold (min list missile-range detection-range) * .66
  
  ;Détection de tous les lanceurs de missiles ennemis à proximité
  let ennemyTarget min-one-of (perceive-specific-robots ennemy RocketLaunchers) with [distance myself <= missileLaunchThreshold] [distance myself]
  
  ;Si l'on a trouvé un lanceur de missile on tire dessus quoi qu'il arrive.
  ;Sinon on tire sur les énemis avec une probabilité d'autant plus grande qu'il est loin de la base
  ifelse ennemyTarget != nobody
  [
    if nb-fafs = 0
    [new-faf 1]
    
    launch-faf ennemyTarget
  ]
  [
    set ennemyTarget min-one-of (perceive-robots ennemy) with [distance myself <= missileLaunchThreshold] [distance myself]
    
    if ennemyTarget != nobody
    [
      let probabilityNumber random-float missileLaunchThreshold
      
      if probabilityNumber >= distance ennemyTarget
      [
        if nb-fafs = 0
        [ new-faf 1 ]

        launch-faf ennemyTarget
      ]
    ]
  ]
end

to goRedBase
  dridriTeamBaseUpdateAvailableEnergy
  dridriTeamBaseConditionalyRequestBots
  dridriTeamBaseCreateBots

  dridriTeamBaseLaunchFAF
  set mem11 energy
end

;; procedure pour initialiser les explorers rouges
to initRedExplorer
end

;; procedure pour initialiser les rocket-launchers rouges
to initRedRocketLauncher
  let creator my-bases with-min [ distance myself ]
  let ennemyBases [mem10] of creator
  set mem5 one-of item (random length ennemyBases ) ennemyBases
end

;; procedure pour initialiser les rocket-launchers rouges
to initRedHarvester
  set mem4 (list 500 500)
  set mem3 min-one-of my-bases [ distance myself ]
end

;; procedure pour initialiser les bases rougesinifinie
to initRedBase
  set mem11 energy
  dridriTeamBaseRequests 1 Harvesters
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; le code de l'equipe rouge basique
;; préfixe : red-team
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
globals [ count_ ]

;fonction atan(x), netlogo ne fournit que atan(x,y)
to-report atan1 [ x ]
  report 1 - atan 1 x * 2 / 180
end

to dridriTeamForwardMove
  let i 0
  while [ free-ahead? speed != nobody and i < 3]
  [
    rt 120
    set i i + 1
  ]
  
  if free-ahead? speed = nobody [ forward-move speed ]
end

to-report dridriTeamMoveToTarget [ d ]
  ifelse distance mem5 > d
  [
    set heading towards mem5
    dridriTeamForwardMove
    report false
  ]
  [ report true ]
end

to-report dridriTeamGetBreedCost [ b ]
  if b = Harvesters [ report harvester-cost ]
  if b = Explorers  [ report explorer-cost ]
  if b = RocketLaunchers [ report rocket-launcher-cost ]
end

to dridriTeamRandomMove
  let patchDir min-one-of neighbors in-cone 5 135 [ count Seeds-here ]
  set heading towards patchDir
  dridriTeamForwardMove
end

;;;;;;;;;;;;;;;;;;;;;;
;; --- EXPLORER --- ;;
;;;;;;;;;;;;;;;;;;;;;;

to dridriTeamExplorerSearchEnemyBases
  dridriTeamRandomMove
  let enemyBase one-of perceive-base ennemy
  
  if enemyBase != nobody
  [
    set mem0 1
    set mem1 enemyBase
    set mem5 min-one-of my-bases [ distance myself ]
  ]
end

;On récupère une base qui n'a pas de coodonnées pour les bases énemies
to dridriTeamExplorerRevealEnemyBase
  ; Une fois que l'on est arrivé à distance de communication d'une base, on vérifie qu'elle ne contient pas déjà la position
  ; de la base que l'on contient et on lui donne cette info
  ; dans tous les cas on se dirige vers la base suivante pour lui passer la position de la base que l'on a trouvé
  if dridriTeamMoveToTarget [detection-range] of mem5
  [
    let enemyBases [mem10] of mem5
    
    ifelse enemyBases = 0
    [ set enemyBases (list mem1) ]
    [ if (length enemyBases = 1) and (item 0 enemyBases != mem1) [ set enemyBases lput mem1 enemyBases ] ]
    
    ask mem5 [ set mem10 enemyBases ]
    set mem5 one-of my-bases with [ self != [mem5] of myself ]
    set mem3 (mem3 + 1)
    if mem3 = 2
    [
      set mem0 0
      set mem3 0
    ]
  ]
end

to goRedExplorer
  if mem0 = 0 [ dridriTeamExplorerSearchEnemyBases ]
  if mem0 = 1 [ dridriTeamExplorerRevealEnemyBase ]
end

;;;;;;;;;;;;;;;;;;;;;
;; --- SOLDIER --- ;;
;;;;;;;;;;;;;;;;;;;;;

to dridriTeamSoldierGoToMeetPoint
  if dridriTeamMoveToTarget 1
  [ set mem0 1 ]
end

to dridriTeamSoldierSwitchToAttack [ baseTarget ]
  set mem0 2
  set mem5 baseTarget
end

to dridriTeamSoldierWaitForAttack
  let soldierAround perceive-specific-robots color RocketLaunchers
  let headingPatch patch (mean [xcor] of soldierAround) (mean [ycor] of soldierAround)
  set heading towards headingPatch
  dridriteamForwardMove
  
  if count soldierAround >= 10
  [
    let baseTarget one-of (list mem1 mem2)
    
    dridriTeamSoldierSwitchToAttack baseTarget
    ask soldierAround with [ mem0 != 2 ]
    [ dridriTeamSoldierSwitchToAttack baseTarget ]
  ]
end

to dridriSoldierAttack
  if dridriTeamMoveToTarget missile-range
  [
    ifelse nb-missiles > 0
    [ launch-rocket towardsxy [xcor] of mem5 [ycor] of mem5 ]
    [
      ifelse nb-fafs > 0
      [ launch-faf mem5 ]
      [
        set mem5 min-one-of my-bases [ distance myself ]
        set mem0 3
      ]
    ]
  ]
end

to dridriTeamSoldierReturnBase
  if dridriTeamMoveToTarget (.95 * [ detection-range ] of mem5) []
end

to goRedRocketLauncher
  if mem0 = 0 [ dridriTeamSoldierGoToMeetPoint ]
  if mem0 = 1 [ dridriTeamSoldierWaitForAttack ]
  if mem0 = 2
  [
    if [energy] of mem5 < 0
    [
      ifelse mem5 = mem1
      [ set mem5 mem2 ]
      [ set mem5 mem1 ]
    ]
    dridriSoldierAttack
  ]
  if mem0 = 3 [ dridriTeamSoldierReturnBase ]
end

to dridriTeamHarvesterSearchFood
  let f min-one-of perceive-food [ distance myself ]

  while [(f != nobody) and (distance f <= 2)] [
    take-food f
    set f min-one-of perceive-food [ distance myself ]
  ]
  
  ;Retourner à la base pour une certaine quantité de nourriture transportée
  if carrying-food? >= mem4
  [
    set mem0 1
    set mem4 2000
  ]
  
  ifelse f != nobody
  [
    set heading towards f
    dridriTeamForwardMove
  ]
  [ dridriTeamRandomMove ]
  
  if mem1 = 1
  [
    let b min-one-of my-bases [ distance myself ]
    
    if distance b >= missile-range
    [ set heading towards b ]
  ]
end

to dridriTeamHarvesterFeedBase
  let targetBase min-one-of my-bases [ distance myself ]
  set heading towards targetBase
  
  ;Plantage des graines dans les patches qui en ont le moins
  if (distance targetBase <= missile-range) and (mem2 < 10)
  [ 
    ifelse mem3 = 0
    [
      let minSeed min-one-of neighbors with [ distance targetBase < missile-range ] [ count Seeds-here ]
      ;ask minSeed [ set pcolor green ]
      set mem3 list [pxcor] of minSeed [pycor] of minSeed
    ]
    [
      let patchM3 patch (item 0 mem3) (item 1 mem3)
      let currentPatch patch-here
      
      ifelse currentPatch = patchM3
      [
        plant-seeds color max-seeds
        set mem3 0
        set mem2 mem2 + 1
      ]
      [ set heading towards patchM3 ]
    ]
  ]
  
  ;On s'approche de la base jusqu'a la distance maximale à laquelle il est possible de lui donner de la nourriture puis on lui donne
  ; et l'on repart à la recherche de nourriture
  if distance targetBase <= 2
  [
    give-food targetBase carrying-food?
   ;Repare à la recherche de nourriture 
    set mem0 0
    set mem1 1;A partir du moment où l'on a nourrit une base on reste dans son périmètre
    set mem2 0
    set mem3 0
  ]
  
  dridriTeamForwardMove
end

;Se déplace aléatoirement. Quand ils trouvent de la nourriture en donne 80% à la base et plante ce qui reste
to goRedHarvester
  if mem0 = 0 [ dridriTeamHarvesterSearchFood ]
  if mem0 = 1 [ dridriTeamHarvesterFeedBase ]
end

to dridriTeamBaseRequests [ n b ]
  if b = Harvesters [ set mem0 max (list 0 (mem0 + n)) ]
  if b = RocketLaunchers [ set mem1 max (list 0 (mem1 + n)) ]
  if b = Explorers [ set mem2 max (list 0 (mem2 + n)) ]
end

to dridriTeamBaseRequestHarvesters [ n ] dridriTeamBaseRequests n Harvesters end

;Si le nombre d'harvesters est plus petit qu'une certaines valeur, recréer des harvesters
to dridriTeamBaseConditionalyRequestHarvester
  let harvesterThreshold 2
  let harvesterNumber count perceive-specific-robots color Harvesters
  ifelse harvesterNumber < harvesterThreshold
  [ dridriTeamBaseRequestHarvesters 1 ]
  [
    if mem0 > 0
    [ dridriTeamBaseRequestHarvesters -1 ]
  ]
end

to dridriTeamBaseRequestSoldiers [ n ]
  dridriTeamBaseRequests n RocketLaunchers
end

to-report dridriTeamComputeFactor [ de ]
  report atan1 de / 3
end
;La quantité de soldat a créer dépend de l'énergie que la base à reçu sur 100 ticks.
;L'idée est d'utiliser une fraction de l'énergie reçu pour créer des soldats.
;Au fur et à mesure que le temps avance, une fraction du plus en plus importante de l'énergie reçue sera utilisé car de plus en plus d'énergie est créée.
;Au max 60% de l'énergie gagnée sur 100 ticks sera utilisée pour créer de nouveaux soldats. Ceci afin de pouvoir toujours avoir une quantité d'énergie qui augmente.

;Si on a perdu de l'énergie  alors on enlèvera des soldats de la file d'attente
to dridriTeamBaseConditionalyRequestSoldier
  if ticks mod 400 = 0
  [
    let dEnergy energy - mem11;mem11 = la variation d'énergie
    ;let f 0.60 * dridriTeamComputeFactor dEnergy
    let newSoldierAmount 0.60 * dEnergy / dridriTeamGetBreedCost RocketLaunchers
    
    ;if mem9 = 1
    ;[ type self type "dE=" type dEnergy type "   f=" type f type "   s=" type newSoldierAmount type "\n" ]
    
    let soldierAmountToRequest floor newSoldierAmount
    
    if soldierAmountToRequest != 0
    [ dridriTeamBaseRequestSoldiers soldierAmountToRequest ]
    set mem11 energy;
  ]
end

to dridriTeamBaseRequestExplorers [ n ] dridriTeamBaseRequests n Explorers end
to dridriTeamBaseConditionalyRequestExplorer
  if ((mem10 = 0) or (length mem10 != 2)) and (ticks mod 400 = 0)
  [ dridriTeamBaseRequestExplorers 1 ]
end

to dridriTeamBaseConditionalyRequestBots
  dridriTeamBaseConditionalyRequestHarvester
  dridriTeamBaseConditionalyRequestSoldier
  dridriTeamBaseConditionalyRequestExplorer
end

to dridriTeamBaseCreateHarvester
  if mem0 > 0
  [
    new-Harvester self
    set mem0 mem0 - 1
  ]
end

to dridriTeamBaseCreateSoldier
  if mem1 > 0
  [
    new-RocketLauncher self
    set mem1 mem1 - 1
  ]
end

to dridriTeamBaseCreateExplorer
  if mem2 > 0
  [
    new-Explorer self
    set mem2 mem2 - 1
  ]
end

to dridriTeamBaseCreateBots
  if create-ok? [ dridriTeamBaseCreateHarvester ]
  if create-ok? [ dridriTeamBaseCreateSoldier ]
  ;if create-ok? [ dridriTeamBaseCreateExplorer ]
end

to dridriTeamBaseLaunchFAF
   let missileLaunchThreshold (min list missile-range detection-range) * .66
  
  ;Détection de tous les lanceurs de missiles ennemis à proximité
  let ennemyTarget min-one-of (perceive-specific-robots ennemy RocketLaunchers) with [distance myself <= missileLaunchThreshold] [distance myself]
  
  ;Si l'on a trouvé un lanceur de missile on tire dessus quoi qu'il arrive.
  ;Sinon on tire sur les énemis avec une probabilité d'autant plus grande qu'il est loin de la base
  ifelse ennemyTarget != nobody
  [
    if nb-fafs = 0
    [new-faf 1]
    
    launch-faf ennemyTarget
  ]
  [
    set ennemyTarget min-one-of (perceive-robots ennemy) with [distance myself <= missileLaunchThreshold] [distance myself]
    
    if ennemyTarget != nobody
    [
      let probabilityNumber random-float missileLaunchThreshold
      
      if probabilityNumber >= distance ennemyTarget
      [
        if nb-fafs = 0
        [ new-faf 1 ]

        launch-faf ennemyTarget
      ]
    ]
  ]
end

to goRedBase
  dridriTeamBaseConditionalyRequestBots
  dridriTeamBaseCreateBots

  dridriTeamBaseLaunchFAF
end

;; procedure pour initialiser les explorers rouges
to initRedExplorer
end

;; procedure pour initialiser les rocket-launchers rouges
to initRedRocketLauncher
  let aBase one-of my-bases
  
  set mem1 [ item 0 mem10 ] of aBase
  set mem2 [ item 1 mem10 ] of aBase
  
  let meetPoint (list 0 0)
  let xCorMeetPoint mean [xcor] of my-bases - 10
  let yCorMeetPoint mean [ycor] of my-bases
  
  set mem5 patch xCorMeetPoint yCorMeetPoint
  
  set heading towards mem5
  
  ask mem5
  [ set pcolor green ]
end

;; procedure pour initialiser les rocket-launchers rouges
to initRedHarvester
  set mem4 500
end

;; procedure pour initialiser les bases rougesinifinie
to initRedBase
  dridriTeamBaseRequestHarvesters 5
  set mem10 (list (base 4) (base 6))
end
